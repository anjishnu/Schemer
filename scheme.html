<html>
<head>
<link href="css/assignments.css" rel="stylesheet" type="text/css">
<title>Proj04</title>
</head>

<body>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Project 04: Scheme</title>
  <!-- <link href="css/projects.css" rel="stylesheet" type="text/css" /> -->
</head>

<body>
  <h2>Project 4: A Scheme Interpreter</h2>

  <blockquote>
    <center>
      <img src="money_tree.png" />
    </center>

    <center>
      <cite>Eval calls apply,<br />
      which just calls eval again!<br />
      When does it all end?</cite>
    </center>
  </blockquote>

  <h3>Change Log</h3>

  <ul>
    <li>
    <u><i> 7-31-2012 </i></u>:
    <ul>
      <li><u>Modified files </u>
        <ul>
          <li><code>scheme.html</code></li>
        </ul>
      </li>
      <li> Relaxed the specification of <code>do_and_form</code> and
        <code>do_or_form</code> -- simply return <code>True</code> or
        <code>False</code>, rather than possibly returning one of the
        operand values. 
      </li>
    </ul>
    <li> 
    <u><i> 7-30-2012 </i></u>: 
    <ul>
      <li> <u>Modified files </u>
        <ul>
          <li><code>scheme.html</code>, <code><a href="scheme.py.html">scheme.py</a></code>,
            <code>tests.scm</code></li>
        </ul>
      </li>
      <li> In <code>do_let_star_form</code>, 
        fixed the 
        call to <code>check_formals</code> (previously, it checked for at
        least three exprs, when it should have been only at least two exprs.
      </li>
      <li>
        Fixed a few problem number mis-labels in <code>tests.scm</code>.
      </li>
      <li>
        Added clarifications to the Logic Forms and the Extra Credit
        <code>case</code> form.
      </li>
    </ul>
    </li>
    <li>
    <u><i>7-28-2012</i></u>
    <ul>
      <li> <u>Modified files</u>
        <ul>
          <li> <code>scheme.html</code></li>
        </ul>
      </li>
                                   
      <li> Added project due date to the spec. </li>
      <li> Clarified how our interpreter will internally represent Scheme
        values. </li>
    </ul>
  </ul>

  <h3>Introduction</h3>

  <p>In this project, you will develop an interpreter for a subset of the
Scheme language. As you proceed, think about the issues that arise in the
design of a programming language; many quirks of languages are the byproduct
of implementation decisions in interpreters and compilers.</p>

  <p>You will also implement some small programs in Scheme, including the
  <code>count_change</code> function that we studied in lecture. Scheme is a simple but
  powerful functional language. You should find that much of what you have learned about
  Python transfers cleanly to Scheme as well as to other programming languages. To learn
  more about Scheme, you can read the original <a href=
  "http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start">Structure and Interpretation of Computer Programs</a> online for free. Examples from chapters 1 and 2 are included as test cases for this project. Language features from Chapters 3, 4, and 5 are not part of this project, but of course you are welcome to extend your interpreter to implement more of the language.</p>

  <p>The project concludes with an open-ended graphics contest that challenges you to
  produce recursive images in only a few lines of Scheme. As an example of what you might
  create, the picture above abstractly depicts all the ways of making change for $0.50
  using U.S. currency. All flowers appear at the end of a branch with length 50. Small
  angles in a branch indicate an additional coin, while large angles indicate a new
  currency denomination. In the contest, you too will have the chance to unleash your
  inner recursive artist.</p>

  <p>This project includes several files, but all of your changes will be made to the
  first two: <code><a href="scheme.py.html">scheme.py</a></code> and <code><a href="tests.scm">tests.scm</a></code>. 
  You can download all of the project code as a <a href="proj04.zip">zip archive</a>.</p>

  <table cellpadding="10">
    <tr>
      <td><code><a href="scheme.py.html">scheme.py</a></code></td>

      <td>The Scheme interpreter</td>
    </tr>

    <tr>
      <td><code><a href="scheme_tokens.py.html">scheme_tokens.py</a></code></td>

      <td>A Tokenizer for scheme</td>
    </tr>

    <tr>
      <td><code><a href="scheme_primitives.py.html">scheme_primitives.py</a></code></td>

      <td>Primitive Scheme data structures and procedures</td>
    </tr>

    <tr>
      <td><code><a href="scheme_test.py.html">scheme_test.py</a></code></td>

      <td>A testing framework for Scheme</td>
    </tr>
    <tr>
      <td><code><a href="tests.scm">tests.scm</a></code></td>
      <td>A collection of test cases written in Scheme that are designed
      to test your Scheme interpreter. You will be adding additional
      test cases to this file, in addition to defining several Scheme
      procedures. </td>
    </tr>
    <tr>
      <td><code><a href="ucb.py">ucb.py</a></code></td>

      <td>Utility functions for 61A</td>
    </tr>
  </table>

  <h3>Logistics</h3>

  <p>This is a three-part project. As in the previous project, you'll work in a team of
  two people, person A and person B. In each part, you will do some of the work
  separately, but most questions can be completed as a pair. Both partners should
  understand the solutions to all questions.</p>

  <p>After completing the first (short) part, you will be able to read and parse Scheme
  expressions. In the second (long) part, you will develop the interpreter in stages:</p>

  <ul>
    <li>Calls on primitive functions (those implemented in Python)</li>

    <li>Symbol evaluation and simple definition</li>

    <li>Lambda expressions and complex (function) definitions</li>

    <li>Calls on functions created by lambda expressions</li>

    <li>Conditional expressions</li>

    <li>The <code>let</code> expression</li>
  </ul>

  <p>Finally, in the third part, you will implement Scheme procedures
  that are similar to some exercises that you previously completed in
  Python.</p>

  <p>There are 30 possible points, along with 4 extra credit points. The extra credit
  problems are a bit involved; we recommend that you complete them all, but only
  <i>after</i> you have the regular stuff working.</p>

  <p>The project is due on <b>Tuesday, August 7th</b> at <b>11:59:59 PM</b>.
  You will must turn in both an electronic and a paper copy. Paper copies
  are to be turned in at the turn-in boxes in <b>283 Soda</b>. On each file that
  you submit, make sure you indicate your TA's name, and the name and logins
  of both Person A and Person B.</p>

  <h3>The Scheme Language</h3>

  <p>Before you begin working on the project, review what you have learned in lecture
  about the <a href=
  "http://inst.eecs.berkeley.edu/~cs61a/sp12/book/interpretation.html#scheme-language">Scheme
  language</a>. If you would like to experiment with a working Scheme interpreter, look
  at <a href="http://inst.eecs.berkeley.edu/~scheme">Stk</a>, which is installed on
  instructional machines as <code>stk</code>. You can also use the online <a href="http://wscheme.appspot.com/">wscheme</a> REPL.

  <p><b>Read-Eval-Print.</b> Run interactively, the interpreter reads Scheme expressions,
  evaluates them, and prints the results. The interpreter uses <code>scm&gt;</code> as the prompt.</p>

  <pre>
    scm&gt; 2
    2
  </pre>

  <p>The starter code for your Scheme interpreter in <code><a href=
  "scheme.py.html">scheme.py</a></code> can successfully evaluate this simple expression,
  since it consists of a single literal numeral. The rest of the examples in this section
  <i>will not</i> work until you complete various portions of the project.</p>

  <p><b>Non-standard Functions.</b></p>

  <p><b>Load.</b> Our <code>load</code> function differs from standard Scheme in that,
  since we don't have strings, we use a symbol for the file name. For example</p>

  <pre>
    scm&gt; (load 'problems.scm)
  </pre>

  <p><b>Turtle Graphics.</b> Finally, to keep up the traditions of recent years, we've
  added some simple routines for turtle graphics, described later,
  that simply call functions in the Python <code>turtle</code> package (whose <a href=
  "http://docs.python.org/py3k/library/turtle.html">documentation</a> we suggest you see;
  for one thing, it will let you try out turtle-graphics programs in Python).</p>

  <p><u>Note:</u> The <code>turtle</code> Python module may not
  be installed by default on your personal computer. However, the
  <code>turtle</code> module is installed on the instructional machines.
  So, if you wish to create turtle graphics for this project (i.e. for
  the contest), then you'll either need to setup <code>turtle</code> on
  your personal computer, or test on your class account. </p>

  <h3>Testing</h3>

  <p>The tests for this project are largely taken from the Scheme
  textbook that 61A used for many years. Examples from relevant
  chapters (and a few more examples to test various corner cases)
  appear in <code><a href="tests.scm">tests.scm</a></code></p>

  <p>You can also compare the output of your interpreter to the expected output by
  passing the file name to <code><a href="scheme_test.py.html">scheme_test.py</a></code>.</p>

  <pre>
    # python3 scheme_test.py tests.scm
  </pre>

  <p>This is a rather useful script. As you'll see, <code><a href="tests.scm">tests.scm</a></code> contains Scheme
  expressions interspersed with comments in the form:

  <pre>
    (+ 1 2)
    ; expect 3
  </pre>

  <p> Here, <code><a href="scheme_test.py.html">scheme_test.py</a></code> will evaluate <code>(+ 1 2)</code>
  using your code in <code><a href="scheme.py.html">scheme.py</a></code>, and output a test failure
  if <code>3</code> is not returned. </p>

  <p>The <code>scheme_test</code> script collects these expected outputs and compares
  them with the actual output from the program, counting and reporting mismatches.</p>

  <p>You can even test that your interpreter catches errors. The problem with error tests
  is that there is no "right" output. Our script, therefore, only requires that error
  messages start with "<code>Error</code>". Any such line will match</p>

  <pre>
    ; expect Error
  </pre>

  <p> Finally, as always, you can run the doctests by doing:

  <pre> python3 -m doctest scheme.py </pre>

  </p>

  <p>Don't forget to use the <code>trace</code> decorator from the <code>ucb</code>
  module to follow the path of execution in your interpreter.</p>

  <p>As you develop your Scheme interpreter, you may find that Python raises various
  uncaught exceptions when evaluating Scheme expressions. As a result, your Scheme
  interpreter will crash. Some of these may be the results of bugs in your program, and
  some may be useful indications of errors in user programs. The former should be fixed
  (of course!) and the latter should be caught and changed into <code>SchemeError</code>
  exceptions, which are caught and printed as error messages by the Scheme
  read-eval-print loop we've written for you. Python exceptions that "leak out" to the
  user in raw form are errors in your interpreter (tracebacks are for implementors, not
  civilians).</p>

  <h3>Preliminary: Read Some Code</h3>

  <p>This project is about modifying a complex piece of existing code. In such a
  situation, it's good to take time at the outset to read what's provided, try to
  understand what's there, and accumulate questions about parts you don't understand
  <i>before</i> trying to mess around with it. Indeed, a lot of what you take away from
  this project will simply be what you learn by reading all the code you <i>don't</i>
  have to write. In many cases, you'll be able to experiment with parts of it in
  isolation, simply by starting up an interactive Python session and using
  <code>import</code> to get access to the parts you'd like to play with.</p>

  <p>Take a look over all the files provided with this project (with your partner, of
  course). Look particularly at <code><a href="scheme_primitives.py.html">scheme_primitives.py</a></code>, which defines the basic
  data structures that Scheme programs manipulate, and at the starter
  implementation in <code><a href="scheme.py.html">scheme.py</a></code>.</p>

  <p>In the file <code><a href="scheme.py.html">scheme.py</a></code>, look at
  <code>read_eval_print</code>, which is the top-level function that defines the
  interpreter's actions. Look also at the class <code>Frame</code>, which
  represents environment frames (just like those in the text and in lecture). Look at the
  <code>run</code> function and what it calls to see how the interpreter gets initialized
  and how the global environment comes to be.</p>

  <p>You won't have to modify <code><a href=
  "scheme_tokens.py.html">scheme_tokens.py</a></code>, but since you will be modifying
  the reader (and since we can ask you anything we want on tests), it might be a good
  idea to understand the routines it provides and how they are used. At any given time,
  the "current port" is a <code>Buffer</code> (see <code><a href=
  "buffer.py.html">buffer.py</a></code>), which is used to provide a
  continuous stream of tokens from a token source. See if you can figure out how to look
  at the token stream produced for a small Scheme file.</p>

  <p><b>Symbol Restrictions.</b> For this project, your Scheme
  interpreter will only accept lower-case characters as valid characters
  in a symbol. For instance, the following is invalid in our Scheme:

  <pre>scm> (define L '(1 2 3))
warning: invalid token: L
scm> (define myList '(1 2 3))
warning: invalid token: myList
</pre>

  </p>

  <h3> Running your Scheme Interpreter </h3>

  <p> To run your Scheme interpreter in interactive mode, do:

  <pre># python3 scheme.py
scm> </pre>
  
  Alternately, you can tell your Scheme interpreter to evaluate the 
  lines of an input file by passing the file name as an argument to
  <code><a href="scheme.py.html">scheme.py</a></code>:

  <pre>
    # python3 scheme.py my_code.scm
  </pre> </p>


  Currently, your Scheme interpreter can handle a few simple expressions,
  such as:

  <pre>scm> 1
1
scm> 42
42
scm> #t
True
scm> 'hi
hi
</pre>

  To exit the Scheme interpreter, issue either <code>Ctrl-c</code> or
  <code>Ctrl-d</code>. Once you've implemented primitive functions, you
  can also invoke the <code>exit</code> primitive function to exit the
  interpreter:

  <pre>scm> (exit)
# 
</pre>

  </p>

  <h3>Part 1: The Reader</h3>

  <p>The function <code>scheme_read</code> in <code><a href=
  "scheme.py.html">scheme.py</a></code> is intended to read in tokens
  from the input source (such as a .scm file, or from the interactive
  prompt) and return Scheme
  expressions in our internal representation. In our Scheme interpreter,
  we will represent Scheme data types in the following way: </p>

  <table border="1" align="center">
  <tr>
  <th> Scheme Data Type</th>
  <th> Our Internal Representation </th>
  </tr>
  <tr>
    <td> Numbers </td>
    <td> Python's built-in <code>int</code>, <code>float</code>
    built-in data types. </td>
  </tr>
  <tr>
    <td> Symbols</td>
    <td> Python's built-in <code>string</code> data type. </code> </td>
  </tr>
  <tr> 
     <td> Booleans (<code>#t</code>, <code>#f</code>)</td>
     <td> Python's built-in <code>True</code>, <code>False</code>
     values. </td>
  </tr>
  <tr>
     <td> Pairs </td>
     <td> The <code>Pair</code> class, defined in the 
     <code><a href="scheme.py.html">scheme.py</a></code> file. </td>
  </tr>
  </table>

  <p>
  <!--Currently, it only handles numbers, symbols, boolean
  values, and the end of file (EOF).-->
  At the moment, the <code>scheme_read</code> can only handle atoms
  (like numbers, symbols, and boolean values) and the quote form. In
  particular, it
  can't handle pairs.
  </p>

  <p><b>Problem 1</b> (2 pt). Your first task, with your partner, is to complete
  the <code>scheme_read</code> function. The <code>scheme_read</code> function
  should repeatedly pop tokens from the <code>input_port</code> (a <code>Buffer</code>
  instance) until it is able to return an expression. For instance:

<pre>
>>> scheme_read(Buffer(tokenize_lines(["42"])))
42
>>> scheme_read(Buffer(tokenize_lines(["4 2 'hi"])))
4    # The Buffer object is now ["2 'hi"]
>>> scheme_read(Buffer(tokenize_lines(["(1 2 3) 'hi 4"])))
Pair(1, Pair(2, Pair(3, NULL)))
>> scheme_read(Buffer(tokenize_lines(["'bagel"])))
Pair("quote", Pair("bagel", NULL))        # 'bagel is treated as (quote bagel)
</pre>

  Note that, depending on the input, <code>scheme_read</code> may only
  have to pop one token from <code>input_port</code>, or it may have to
  pop many tokens. </p>

<ul>
  <li> If the <code>input_port</code> currently refers to an <b>atom</b>,
       which are booleans, numbers, symbols, and NULL, then simply
       return the atom. 
       <ul>
         <li> To tell if a token is an atom, use the <code>scheme_atomp</code>
              procedure, defined in <code><a href="scheme_primitives.py.html">scheme_primitives.py</a></code>.
         </li>
       </ul>
  <li> If the current token refers to the beginning of a <b>quote</b> (such
       as <code>'bagel</code>), then treat the quoted symbol as the
       special-form <code>(quote bagel)</code>.
  </li>
  <li> If the current token is a left-paren <code>"("</code>, then we
       are starting a new <b>pair</b>. </li>
</ul>

  <p>In <code>scheme_read</code>, the first two cases (atoms, quotes)
     are already handled for you. Your task is to handle the third
     case, which deals with pairs.
  </p>

  <p>The syntax for pairs and lists is a left parenthesis, followed by a "tail", defined
  as</p>

  <ul>
    <li>A right parenthesis, indicating the null list, or</li>

    <li>A Scheme expression, <i>H</i>, followed either by

      <ul>
        <li>A period, a Scheme expression, <i>T</i>, and a right parenthesis.</li>

        <li>Or (recursively) by a tail, <i>T</i>.</li>
      </ul>In either case, the indicated value is a pair consisting of <i>H</i> and
      <i>T</i>.
    </li>
  </ul>

  <p> The internal representation for Scheme's Null value that we will
  use is the global variable <code>NULL</code>, defined in
  <code><a href="scheme_primitives.py.html">scheme_primitives.py</a></code>. </p>

  <p>The provided (incomplete) nested function <code>read_tail</code>
  should read the tail and return its value. For
  example, the value that <code>scheme_read</code> should return for "<code>(1 2 . 3)</code>"
  consists of the value of the tail "<code>1 2 . 3)</code>", which is</p>

  <ul>
    <li>the pair consisting of the Scheme value <code>1</code> and the value of the tail
    "<code>2 . 3)</code>", which is

      <ul>
        <li>the pair consisting of the Scheme value <code>2</code> and the Scheme value
        <code>3</code>.</li>
      </ul>
    </li>
  </ul>Thus, the value that <code>read_tail</code> would return is:
  <code>Pair(1, Pair(2, 3))</code>.

  <p>As another example, the value returned for "<code>(1 2)</code>" is the value of the
  tail "<code>1 2)</code>", which is</p>

  <ul>
    <li>the pair consisting of the Scheme value <code>1</code> and the value of the tail
    "<code>2)</code>", which is

      <ul>
        <li>the pair consisting of the Scheme value <code>2</code> and the value of the
        tail "<code>)</code>", which is the empty list.</li>
      </ul>
    </li>
  </ul>so that the value denoted is <code>Pair(1, Pair(2, NULL))</code>.

  <!--
  <p>You'll be able to test the resulting reader easily enough, since the initial
  project simply prints the Scheme expressions that it reads without evaluating them, so
  a Unix command like</p>

  <pre>
    # python3 scheme.py tests.scm
  </pre>
  will just read <code>tests.scm</code> (or any other file full of Scheme
  expressions), convert them to internal Scheme values, and print out these values. -->

  <p> If you've completed <code>read_tail</code> correctly, then the
  following expressions should evaluate correctly in your Scheme
  interpreter:

  <pre># python3 scheme.py
scm> 42
42
scm> '(1 2 3)
(1 2 3)
scm> '()
nil
scm> '(1 (2 3) (4 (5)))
(1 (2 3) (4 (5)))
scm> '(1 (9 8) . 7)
(1 (9 8) . 7)
scm> '(hi there . (cs . (student)))
(hi there cs student)
</pre>

  Add more tests to the beginning of the <code>tests.scm</code> to make
  sure that your reader is working correctly. </p>

  <p><u>Note:</u> Make sure that your <code>scheme_read</code> and
  <code>read_tail</code> functions are indeed working correctly
  before moving on. Because the subsequent exercises rely on
  <code>scheme_read</code> to correctly process lines, any bugs in your
  <code>scheme_read</code> function will cause strange and unexpected
  errors in the
  later exercises.
  </p>

  <h3>Part 2: The Evaluator</h3>

  <p> Now, we will implement an evaluator. </p>

<p> The main part of the evaluator is within <code>scheme_eval</code> and
<code>scheme_apply</code>. Assuming Problem 1 has been done correctly,
your evaluator should be able to correctly handle atoms (except for 
symbols), quoting, and lists.</p>
  
  <p> However, function calls will not work yet -- the <code>scheme_apply</code>
is incomplete. In the next exercise, we will implement primitive procedures.</p>

  <p><b>Problem 2.</b> Read <code>scheme_apply</code>. Notice that, for
primitive procedures, <code>scheme_apply</code> calls the <code>apply_primitive</code>
procedure, which should apply a primitive procedure to the 
provided arguments, with respect to some environment.</p>

<p> Scheme primitive procedures will be represented internally as instances
of the <code>PrimitiveProcedure</code> class, defined in 
<code><a href="scheme_primitives.py.html">scheme_primitives.py</a></code>. A <code>PrimitiveProcedure</code> instance
has two instance attributes: 
<ul>
  <li> <code>self.fn</code> -- The actual primitive function object
(this is a <emph>Python</emph> function object!) </li>
  <li> <code>self.use_env</code> -- A boolean flag that indicates whether
or not this primitive procedure will expect the current environment to
be passed in as the last argument. </li>
</ul>

To see a list of all Scheme primitive functions, look in the
<code><a href="scheme_primitives.py.html">scheme_primitives.py</a></code> file -- any function definition
with the <code>@primitive</code> decorator will be added to the 
globally-defined <code>_PRIMITIVES</code> list. </p>

<p>
The <code>apply_primitive</code> procedure is incomplete. With both
you and your partner, complete
the definition so that the primitive procedure is applied to its
arguments. In particular,
also make sure that your <code>apply_primitive</code> solution does the
following:
<ul>
  <li> If the <code>procedure.use_env</code> is <code>True</code>, then
  pass the current environment </code>env</code> as the last argument. </li>
  <li> If calling the function results in a <code>TypeError</code> exception
  being thrown, then raise a <code>SchemeError</code>.</li>
</ul>

</p>

<p> Note that, even after you complete <code>apply_primitive</code>, 
your Scheme interpreter will still not be able to apply primitive
procedures. This is because your Scheme interpreter still doesn't know
how to look up the values for the primitive procedure symbols (such as
<code>+</code>, <code>*</code>, and <code>car</code>).
In the next two steps, you and your partner will
implement symbol lookup and symbol definition. </p>

  <p><b>Problem A2</b> (2 pt). In this step, you will get simple 
  symbol evaluation and
  definition to work. Currently, your Scheme interpreter is unable to 
  find the value of some defined symbol, even for the already-defined
  primitive procedures. </p>

<p>The main code that will deal with variable name lookups is located in
the <code>Frame</code> class, in <code><a href="scheme.py.html">scheme.py</a></code>. A <code>Frame</code>
instance has two instance attributes:

<ul>
  <li> <code>self.inner</code> -- a dictionary that maps variable names
  to values. </li>
  <li> <code>self.parent</code> -- a pointer to a parent <code>Frame</code>
  instance. By definition, the parent of the Global Frame is
  <code>None</code>. </li>
</ul>

Currently, the <code>find</code> method is incomplete -- at the moment,
it always raises an <code>"unknown identifier"</code> error.
The <code>find</code>
method should, given a symbol <code>sym</code>, return the first
<code>Frame</code> that contains a definition for <code>sym</code>. Your
<code>find</code> procedure should behave in the following way:

<ul>
  <li> If <code>sym</code> is defined in the current <code>Frame</code>,
  then return the current <code>Frame</code>. </li>
  <li> If <code>sym</code> is <b>not</b> defined in the current
  <code>Frame</code>, then <code>find</code> should follow the 
  <code>parent</code> pointer until it finds some <code>Frame</code> 
  that contains a definition for <code>sym</code>. </li>
  <li> If the symbol <code>sym</code> is not found in the
  Global Frame, then the <code>find</code> method should raise a 
  <code>SchemeError</code>. </li>
</ul>

</p>

<p>After you complete this problem, you should be able to ask for the
value of primitive procedures within the Scheme interpreter (such as
<code>+</code>, <code>*</code>, and <code>car</code>). In particular,
you should be able to call primitive procedures!</p>

<pre>scm&gt; +
&lt;scheme_primitives.PrimitiveProcedure object at 0x2742d50&gt;
scm> (+ 1 2)
3
scm> (* 3 4 (- 5 2) 1)
36
</pre>

  <p><b>Problem B2</b> (2 pt). There are two missing parts in the method
  <code>do_define_form</code>, which handles the <code>(define&nbsp;...)</code>
  construct. Here, we'll do just the first part: handling cases like</p>

  <pre>
    (define pi2 (* 2 3.1415926))
  </pre>
  where the defined symbol appears alone. Fill in the missing piece to make this
  work. First, you'll want to see how <code>do_define_form</code> is
  called (it's called within <code>scheme_eval</code>). Then, you'll
  want to take a look at the <code>Frame.define</code>
  method. Some questions that you might want to answer are: what type
  of object is
  <code>vals</code>? How do I get the symbol (i.e. variable name)
  from <code>vals</code>,
  and how do I compute the <u>value</u> that I should bind the symbol
  to in the current environment <code>env</code>? </p>

  <p>When combined with your partner's work on A2, you should now be able to do things
  like

  <pre>
    scm&gt; (define x 15) 
    scm&gt; (define y (* 2 x))
    scm&gt; y 
    30
    scm&gt; (+ y (* y 2) 1)
    91
    scm&gt; (define x 20)
    scm&gt; x
    20
  </pre>

  <p>Now that you can created symbols and given them simple values, it should be easy to
  come up with tests for A2 and B2. Add your tests to <code>tests.scm</code>.</p>

  <p> At this point in the project, your Scheme interpreter should be
  be able to support the following features:
    <ul>
      <li> Evaluate atoms, which include numbers and symbols.</li>
      <li> Handle the <code>quote</code> form, such as <code>'brian</code> </li>
      <li> Evaluate lists. </li>
      <li> Define symbols, i.e. <code>(define myval 42)</code>. </li>
      <li> Evaluate (look-up) symbols. </li>
      <li> Call primitive procedures, such as <code>(+ (- 4 2) 5)</code> </li>
    </ul>
        
  However, one notable missing feature is <b>user-defined functions</b>.
  In the next few steps, you will implement this very-useful feature. </p>

  <p>In our interpreter, user-defined functions will
  be represented as instances of the <code>LambdaProcedure</code> class,
  defined in <code><a href="scheme.py.html">scheme.py</a></code>. A <code>LambdaProcedure</code>
  instance consists of the following instance attributes:
  <ul>
    <li> <code>self.formals</code> -- A Scheme list of the formal
    parameters that this lambda function expects. </li>
    <li> <code>self.body</code> -- A single Scheme expression, consisting
    of the body of this function. </li>
    <li> <code>self.env</code> -- The environment in which this function
    was created. </li>
  </ul>
  

</p>

<p>
  <b>Problem 3</b> (2 pt). Before we can call user-defined functions, we need to implement
  a piece of scheme syntax called <code>begin</code>. <code>begin</code> works as follows:
  <pre>
    scm&gt; (begin (+ 2 3) (+ 5 6))
    11
    scm&gt; (begin (display 3) (newline) (+ 2 3))
    3
    5
  </pre>
  <code>begin</code> executes all the statements given as arguments, and then returns what the last statement evaluates to.
</p>

  <p><b>Problem A4</b> (2 pt). Before we can call <code>LambdaProcedure</code>s, we must
  be able to create them. At the moment, the <code>do_lambda_form</code> method, which
  creates <code>LambdaProcedure</code> values, is incomplete. Once you
  complete <code>do_lambda_form</code>, you can check
  your work by typing in lambda expressions to the interpreter. You should see something
  like this:

  <pre>
    scm&gt; (lambda (x y) (+ x y))
    (lambda (x y) (+ x y))
  </pre>

  Remember that, in Scheme, it is legal to have function bodies with
  more than one expression:
  <pre>
    STk> ((lambda (y) 42 (* y 2)) 5)
    10
  </pre>
  
  In order to more-easily implement this behavior, your
  <code>do_lambda_form</code> should do the following. If 
  <code>do_lambda_form</code> detects
  that the current lambda body has multiple expressions, then the
  <code>do_lambda_form</code> function should place the expressions
  inside of an outer <code>(begin ...)</code> expression, and replace
  the lambda's body with the <code>begin</code> expression:

  <pre>
    scm&gt; (lambda (y) 42 (* y 2))
    (lambda (y) (begin 42 (* y 2)))
  </pre>
  For an explanation of why the <code>begin</code> is inserted, see the
  <code>__init__</code> function for the <code>LambdaProcedure</code> class.

  This workaround will allow us to handle multi-expression function
  bodies in the same manner as single-expression function bodies. </p>

  <p><b>Problem B4</b> (2 pt). Currently, your Scheme interpreter is
  able to define user-defined functions in the following manner (assuming
  that <b>Problem A4</b> is done):

  <pre>
    scm&gt; (define f (lambda (x) (* x 2)))
  </pre>

  However, we'd like to be able to use the shorthand form of defining
  functions:

  <pre>
    scm&gt; (define (f x) (* x 2))
  </pre>

  <p>Modify the <code>do_define_form</code> function so that it correctly
  handles the shorthand function definition form. Make sure that it can
  handle multi-expression bodies. </p>

  <p> Here's a tip. You can think of the short-hand form of defining
  functions as doing the following:

  <pre>(define (square x) (* x x)) </pre>

  Becomes:
  
  <pre>(define square (lambda (x) (* x x))) </pre> </p>

  <p>After you complete <b>Problem A4</b> and <b>Problem B4</b>, 
  you should be able to define user-defined functions.
  However, your interpreter can't actually call them yet. Next, you
  and your partner will extend your interpreter to allow the <b>invocation</b>
  of user-defined functions. </p>

  <p><b>Problem A5</b> (3 pt). The <code>make_call_frame</code> method of
  the <code>Frame</code> class is incomplete. Your task is to complete
  it.</p>

  <p> The <code>make_call_frame</code> method should simulate the
  process of calling a user-defined function. Namely, this involves:
    <ol>
      <li> Creating a new Frame. </li>
      <li> Binding formal parameters to its associated values (the
      arguments have already been evaluated with respect to the caller's
      environment).</li>
      <li> Extending the Frame that the user-defined function was
      defined in. </li>
    </ol>
  </p>

  <p>Don't forget the cases where the formal parameter list contains a trailing "varargs"
  entry, as in:

  <pre>
    (define (format port form . args) ...)
  </pre>
  One unifying way to handle this case along with the simple lists-of-symbols is to
  consider the formals list as a kind of <i>pattern</i> that is matched against the list
  of argument values. That is, the formals list <i>matches</i> the argument list if you
  treat each symbol in the formals list as a <i>pattern variable</i> or <i>wildcard</i>
  that matches any expression. Thus, the list of values <code>(1 2 3)</code> has the
  internal structure

  <pre>
    Pair(<i>number</i>, Pair(<i>number</i>, Pair(<i>number</i>, NULL)))
  </pre>

  while the formals list <code>(a . b)</code> has the structure

  <pre>
    Pair(<i>symbol a</i>, <i>symbol b</i>)
  </pre>

  These have the same form if we match symbol <code>a</code> to the number 1 and
  symbol <code>b</code> to <code>Pair(<i>number</i>, Pair(<i>number</i>, NULL))</code>
  Likewise, the ordinary formals list <code>(a b c)</code> has the structure

  <pre>
    Pair(<i>symbol a</i>, Pair(<i>symbol b</i>, Pair(<i>symbol c</i>, NULL)))
  </pre>

  so it matches the argument list, too.

  <p><b>Problem B5</b> (3 pt). The function <code>check_formals</code>, which
  checks the formals-list argument to <code>make_call_frame</code>, 
  currently does nothing at the
  moment. Fix it so that <code>check_formals</code> raises a
  <code>SchemeError</code> if the list of <code>formals</code> is
  invalid. </p>

  <p>
  In particular, make sure that it supports the following argument
  syntax:
  <pre>
scm> (lambda (x y z) (+ x y z))
scm> (lambda (x . nums) (* x (reduce + nums)))
scm> (lambda nums (reduce * nums))
  </pre>

  And make sure that it rejects the following:

  <pre>
scm> (lambda (x (y) z) (* x y z))
scm> (lambda (x y . z a) (* x y z a))
scm> (define (fn x 2) (+ x 2))
  </pre>
  </p>

  <p><b>Problem 6</b> (3 pt). Finally, both you and your partner
  will modify <code>scheme_apply</code> to correctly handle
  user-defined functions. Complete the <code>scheme_apply</code>
  function so that it does the following:

  <ol>
    <!-- <li> Evaluate the arguments <code>args</code> with respect to the
    current <code>Frame</code>. </li> -->
    <li> Create a new <code>Frame</code>, with all formal parameters
    bound to its associated evaulated arguments. </li>
    <li> Evaluate the body of <code>procedure</code> with respect to
    this new frame. </li>
    <li> Return the value of the call to <code>procedure</code>. </li>
  </ol>

  <p>After you complete <code>scheme_apply</code>, user-defined 
  functions (and lambda functions)
  should work in your Scheme interpreter.

  Be sure to add
  tests for Problems 3&ndash;6   to <code>tests.scm</code></p>

  <p><b>Problem 7.</b> The basic Scheme conditional constructs are 
  <code>if</code>,
  <code>and</code>, <code>or</code>, and <code>cond</code>. In the
  next section, you and your partner will implement these conditional
  special forms. </p>

  <p> Remember that the logical forms (<code>and</code>, <code>or</code>)
  are <i>short-circuiting</i>. This means that not all arguments to an
  <code>and</code>/<code>or</code> should be evaluated, depending on
  the situation.</p>

  <p> For <code>and</code>, your interpreter should evaluate each 
  argument from left-to-right, and if any argument evaluates to a 
  false value,
  then you stop evaluating the <code>and</code> and return <code>False</code>.
  In particular, if all arguments are a true value, then <code>and</code>
  should return <code>True</code>.
  </p>
  <p> For <code>or</code>, your interpreter should evaluate each
  argument from left-to-right, and if any argument evaluates to a
  true value, then you stop evaluating the <code>or</code> and return
  <code>True</code>. If all arguments are false values, then <code>or</code>
  should return <code>False</code>.
  </p>

  <p> Here are a few examples:
  <pre>scm> (and 4 5 6)
True    ; all operands are true values
scm> (or 5 2 1)
True    ; 5 is a true value
scm> (and #t #f 42 (/ 1 0))
False    ; short-circuiting behavior of and
scm> (or 4 #t (/ 1 0))
True    ; short-circuiting behavior of or 
  </pre>
  </p>

  <p> You might find the <code>scheme_true</code> function useful,
  defined in <code><a href="scheme_primitives.py.html">scheme_primitives.py</a></code>. </p>

  <p> <u>Note:</u> When <code>scheme_eval</code> evaluates one of
  the conditional constructs (<code>if</code>, <code>and</code>,
  <code>or</code>, <code>cond</code>, <code>begin</code>,
  <code>case</code>), notice that it calls <code>scheme_eval</code>
  on the <b>return value</b> of the relevant <code>do_FORM</code>
  procedures (<code>do_if_form</code>, <code>do_cond_form</code>, etc.). Take care that
  your Scheme interpreter doesn't inadvertantly call 
  <code>scheme_eval</code> on the same value twice, or else you might
  get the following invalid behavior:

<pre>
    scm> (if (= 42 42) 'hello 'goodbye)
    Error: unknown identifier: hello
</pre>
 
  </p>

  <p><b>Problem A7</b> (3 pt). Currently, <code>if</code> and
  <code>and</code> forms don't work correctly (<code>if</code> always
  evaluates to <code>nil</code>, and <code>and</code> always evaluates
  to <code>True</code>). Fill in the
  implementations of <code>do_if_form</code> and <code>do_and_form</code>. 
  Make sure you correctly implement the short-circuiting behavior of
  <code>and</code>, as described above. Add
  test cases to <code>tests.scm</code>. </p>

  <p><b>Problem B7</b> (3 pt). For the second half, fill in the implementations of
  <code>do_cond_form</code> and <code>do_or_form</code>. Make sure you
  correctly implement the short-circuiting behavior of <code>or</code>,
  as described above. Add test cases
  to <code>tests.scm</code>.</p>

  <p> In particular, make sure that your <code>do_cond_form</code> 
  correctly handles the following forms: 

  <pre>
scm> (cond ((= 4 3) 'nope)
         ((= 4 4) 'hi)
         (else 'wait))
hi
scm> (cond ((= 4 3) 'wat)
         ((= 4 4))
         (else 'hm))
True
scm> (cond ((= 4 4) 'here 42)
         (else 'wat 0))
42
</pre>

  For the last example, where the body of a <code>cond</code> has 
  multiple expressions, you might find it helpful to 'convert' 
  <code>cond</code>-bodies with multiple expression bodies into 
  a single <code>begin</code> expression, i.e.:

<pre>
scm> (cond ((= 4 4) 'here 42))
</pre>

  Becomes:

<pre>
scm> (cond ((= 4 4) (begin 'here 42)))
</pre>           

  <p> A few clarifications:
  <ul>
    <li> In this project, all <code>else</code> clauses must contain
    at least one expression, i.e. the following <code>cond</code>
    usage is invalid in our project:
      <pre>scm> (cond ((= 4 3) 5) (else)) </pre>
    </li>
    <li> If no tests of a <cond>cond</code> are satisfied, then your
    <code>do_cond_form</code> should return <code>None</code> (which
    signals an <i>undefined expression</i>. It is valid for your project
    code to issue an error in the following way:
<pre>scm> (cond ((= 4 5) 1))
Error: Cannot evaluate an undefined expression.
</pre>
    </li>
  </ul>

  <p><b>Problem 8</b> (3 pt). The <code>let</code> special form introduces local
  variables, giving them their initial values. For example,</p>

  <pre>
    scm&gt; (define x 'hi)
    scm&gt; (define y 'bye)
    scm&gt; (let ((x 42)
             (y (* 5 10)))
          (list x y))
    (42 50)
    scm&gt; (list x y)
    (hi bye)
  </pre>

  Implement
  the <code>do_let_form</code> method to have this effect and (need we say it at this
  point?) test it, by adding test cases to <code>tests.scm</code>. Make
  sure your <code>let</code> correctly handles multi-expression
  bodies:

  <pre>scm> (let ((x 42)) x 1 2)
2
</pre>

  <p> As a reminder, you can think of the <code>let</code> form as
  doing the following:

<pre>
scm> (let ((x 42) (y 16)) (+ x y))
58
</pre>

Becomes:

<pre>
scm> ((lambda (x y) (+ x y)) 42 16)
58
</pre>

  Thus, a <code>let</code> form implicitly creates a new
  <code>Frame</code> (containing the <code>let</code> bindings)
  which extends the current environment, and evaluates the body of the
  <code>let</code> with respect to this new <code>Frame</code>. This is
  very much exactly like a user-defined function call. Note that, in your
  project code, you don't have to actually create a 
  <code>LambdaProcedure</code> and call it - instead, you can
  create a new <code>Frame</code>, add the necessary bindings, and
  evaluate the expressions of the <code>let</code> body with respect to
  the new <code>Frame</code> (indeed, the provided skeleton code 
  points you towards this approach).</p>

<p> Reminder: the bindings created by a <code>let</code> are not
    able to refer back to previously-declared bindings from the same 
    <code>let</code>:

<pre>
STk> (let ((x 42) (y (+ x 2))) (+ x y))
*** Error:
    unbound variable: x
</pre>
  
   Make sure your interpreter behaves in this way too.</p>


  <p><b>Extra Credit 1.</b> (2 pt). The <code>let*</code> construct is like
  <code>let</code>, except that each initialization expression "sees" the definitions
  that have gone before. Essentially,</p>

  <pre>
    (let* ((x 10) 
          (y (+ x 5))) 
      (list x y))
  </pre>

  is the same as

  <pre>
    (let ((x 10)) 
      (let (y (+ x 5)) 
        (list x y)))
  </pre>and therefore has the value <code>(10 15)</code>. 
  Implement this special form (and, yes,
  test it).

  <p><b>Extra Credit 2</b> (2 pt). The <code>case</code> construct is a fancy conditional
  similar to the Java and C/C++ <code>switch</code> statement. Here are some examples
  from the Scheme reference manual:</p>

  <pre>
    scm&gt; (case (* 2 3) ((2 3 5 7) 'prime) ((1 4 6 8 9) 'composite)) 
    composite 
    scm&gt; (case (car '(c d)) ((a e i o u) 'vowel) ((w y) 'semivowel) (else 'consonant))
    consonant
    scm&gt; (define x 3) (define y 10)
    scm&gt; (case (car '(+ * /)) ((+ add) (+ x y)) ((* mult) (* x y)) ((/ div) (/ x y))) 
    13
  </pre>
  
  <p>
  The first operand is evaluated, but the first element of each of the subsequent
  operands is not evaluated (it's implicitly quoted). As for <code>cond</code> the
  remaining items in the matching operand are evaluated, and the value of the last is the
  value of the <code>case</code>. Implement and test this special form.
  </p>

  <p>For this project, we will slightly differ from the behavior of 
  <code>STk</code>'s implementation of <code>case</code>. In our Scheme
  interpreter, assume that the correct syntax for the <code>case</code> is:

  <pre>
    (case &lt;expr&gt; (&lt;lst_0&gt; &lt;expr_0&gt;) ... (&lt;lst_N&gt; &lt;expr_N&gt;))

or:
    
    (case &lt;expr&gt; (&lt;lst_0&gt; &lt;expr_0&gt;) ... (&lt;lst_N&gt; &lt;expr_N&gt;) (else &lt;expr_else&gt;))
  </pre>

  There must be at least one <code>(&lt;lst_i&gt; &lt;expr_i&gt;)</code>
  operand. Each <code>&lt;lst_i&gt;</code> is a list of symbols or
  literals:

<pre>
    &lt;lst_i&gt; := (sym_0 ... sym_N)
</pre>

  An empty  <code>&lt;lst_i&gt;</code>
  should be accepted by your interpreter (even though that case will
  never be taken), such as:

<pre>
    scm> (case 2 (() 'never-get-here) (else 'good))
    good
</pre>

  </p>

  <p>
  If no cases of a <code>case</code> expression are taken, and an
  <code>else</code> is <b>not</b> present, then <code>case</code>
  should return <code>False</code>:
  </p>

<pre>
    scm> (case 42 ((1 2 3) 'case-a) (('a 'b 'c) (* 2 3)))
    False
</pre>

  <p>
  In particular, make sure that the all operands in the
  <code>case</code> are correctly formed. If any operands are ill-formed
  (according to our syntax), 
  such as <code>(case 2 (2 'a) (else 'b))</code>, then raise 
  a <code>SchemeError</code> with a meaningful error message.
  </p>

  

  <h3>We're There!</h3>

  <p>You should have been adding tests to <code>tests.scm</code> as you did each problem.
  In any case, make sure you have a reasonably complete set, since the readers will be
  looking at it. Your program should pass all your tests when you (or the autograder) run
  <code># python3 scheme_tests.py tests.scm</code></p>

  <p>Your Scheme interpreter implementation is now complete.</p>

  <h3>Part 3: Write Some Scheme</h3>

  <p>Not only is your Scheme interpreter itself a tree-recursive program, but it is
  flexible enough to evaluate <i>other</i> recursive programs. Implement the following
  procedures in Scheme at the bottom of <code><a href="tests.scm">tests.scm</a></code>,
  along with some calls and expected results.</p>

  <p><b>Problem A9</b> (3 pt). Implement the <code>filter</code> procedure, which takes
  two arguments, a procedure name and a list and returns a list that
  contains all elements of the input list for which applying the named procedure outputs
  a true value (i.e., something other than <code>#f</code>). 

  <p><b>Problem B9</b> (3 pt). Implement the <code>reverse</code> procedure, which takes
  a list and returns the reverse of that list.</p>

  <p><b>Problem 10</b> (2 pt). Implement the <code>count-change</code> procedure, which
  counts all of the ways to make change for a <code>total</code> amount, using coins with
  various denominations (<code>denoms</code>), but never uses more than
  <code>max-coins</code> in total. Write your implementation in <code>tests.scm</code>.
  The procedure definition line is provided, along with U.S. denominations.</p>

  <p><b>Problem 11</b> (2 pt) Implement the <code>count-partitions</code> procedure,
  which counts all the ways to partition a positive integer <code>total</code> using only
  pieces less than or equal to another positive integer <code>max-value</code>. The
  number <code>5</code> has 5 partitions using pieces up to a <code>max-value</code> of
  <code>3</code>:</p>

  <div class="code">
    3, 2 (two pieces) 3, 1, 1 (three pieces) 2, 2, 1 (three pieces) 2, 1, 1, 1 (four
    pieces) 1, 1, 1, 1, 1 (five pieces)
  </div>

  <p><b>Problem 12</b> (3 pt). Implement the <code>list-partitions</code> procedure,
  which lists all of the ways to partition a positive integer <code>total</code> into at
  most <code>max-pieces</code> pieces that are all less than or equal to a positive
  integer <code>max-value</code>. <i>Hint</i>: Define a helper function to construct
  partitions.</p>

  <p><b>Congratulations!</b> You have finished the final project for 61A! Assuming your
  tests are good and you've passed them all, consider yourself a proper computer
  scientist!</p>

  Now, get some sleep, you've earned it!

<h3><a name="turtle">Contest: Recursive Art</a></h3>

<p>We've added a number of primitive drawing procedures that are collectively
called "turtle graphics".  The <i>turtle</i> represents the state of the drawing
module, which has a position, an orientation, a pen state (up or down), and a
pen color. The <code>tscheme_<i>x</i></code> functions in
<code><a href="scheme_primitives.py.html">scheme_primitives.py</a></code> are the implementations of these
procedures, and show their parameters with a brief description of each.
The Python <a
  href="http://docs.python.org/release/3.2/library/turtle.html">documentation of
  the turtle module</a> contains more detail.</p>

<p><b>Contest</b> (3 pt). Create a visualization of an iterative or
recursive process of your choosing, using turtle graphics. Your implementation
must be written entirely in Scheme, using the interpreter you have built (no fair
extending the interpreter to do your work in Python, but you can expose other
turtle graphics functions from Python if you wish).

<p>Prizes will be awarded for the winning entry in each of the following
categories.  

<ul>
  <li><b>Featherweight.</b> At most 128 words of Scheme, not including comments
  and delimiters. 

  <li><b>Heavyweight.</b> At most 1024 words of Scheme, not including comments
  and delimiters.
</ul>

<p>Entries (code and results) will be posted online, and winners will be
selected by popular vote.  The voting instructions will read:

<blockquote>
Please vote for your favorite entry in this semester's 61A Recursion Exposition
contest.  The winner should exemplify the principles of elegance, beauty, and
abstraction that are prized in the Berkeley computer science curriculum.  As an
academic community, we should strive to recognize and reward merit and
achievement (translation: please don't just vote for your friends).
</blockquote>

<p>To improve your chance of success, you are welcome to include a title and
descriptive <a href="http://en.wikipedia.org/wiki/Haiku">haiku</a> in the
comments of your entry, which will be included in the voting.

Place your completed entry into the <code><a
    href="contest.scm">contest.scm</a></code> file.

<p> Contest submissions are due <b>next Friday</b> (August 3rd, 2012).
Note that this is before the project itself is due. In the following
Tuesday's homework, you will vote on your favorite drawing.</p>


</body>
</html>

</body>
</html>